#!/usr/bin/env ruby
# frozen_string_literal: true

require "siglip2"
require "optparse"
require "json"

options = {
  model: Siglip2::DEFAULT_MODEL,
  quantization: Siglip2::DEFAULT_QUANTIZATION,
  format: "json"
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: siglip2-embed-image [options] IMAGE_PATH"

  opts.on("-m", "--model MODEL", "Model name (default: #{Siglip2::DEFAULT_MODEL})") do |m|
    options[:model] = m
  end

  opts.on("-q", "--quantization QUANT", "Quantization (default: #{Siglip2::DEFAULT_QUANTIZATION})") do |q|
    options[:quantization] = q
  end

  opts.on("-f", "--format FORMAT", "Output format: json, csv (default: json)") do |f|
    options[:format] = f
  end

  opts.on("-l", "--list-models", "List available models") do
    puts "Available models:"
    Siglip2.list_models.each { |m| puts "  #{m}" }
    exit
  end

  opts.on("-L", "--list-quantizations", "List available quantizations") do
    puts "Available quantizations:"
    Siglip2.list_quantizations.each { |q| puts "  #{q}" }
    exit
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end

parser.parse!

if ARGV.empty?
  puts parser
  exit 1
end

image_path = ARGV[0]

unless File.exist?(image_path)
  warn "Error: Image file not found: #{image_path}"
  exit 1
end

begin
  model = Siglip2::Model.new(model_name: options[:model], quantization: options[:quantization])
  embedding = model.encode_image(image_path)

  case options[:format]
  when "json"
    puts JSON.generate(embedding)
  when "csv"
    puts embedding.join(",")
  else
    puts JSON.generate(embedding)
  end
rescue Siglip2::Error => e
  warn "Error: #{e.message}"
  exit 1
end
